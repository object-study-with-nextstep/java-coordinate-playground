## [NEXTSTEP 플레이그라운드의 미션 진행 과정](https://github.com/next-step/nextstep-docs/blob/master/playground/README.md)

---
## 학습 효과를 높이기 위해 추천하는 미션 진행 방법

---
1. 피드백 강의 전까지 미션 진행 
> 피드백 강의 전까지 혼자 힘으로 미션 진행. 미션을 진행하면서 하나의 작업이 끝날 때 마다 add, commit
> 예를 들어 다음 숫자 야구 게임의 경우 0, 1, 2단계까지 구현을 완료한 후 push

![mission baseball](https://raw.githubusercontent.com/next-step/nextstep-docs/master/playground/images/mission_baseball.png)

---
2. 피드백 앞 단계까지 미션 구현을 완료한 후 피드백 강의를 학습한다.

---
3. Git 브랜치를 master 또는 main으로 변경한 후 피드백을 반영하기 위한 새로운 브랜치를 생성한 후 처음부터 다시 미션 구현을 도전한다.

```
git branch -a // 모든 로컬 브랜치 확인
git checkout master // 기본 브랜치가 master인 경우
git checkout main // 기본 브랜치가 main인 경우

git checkout -b 브랜치이름
ex) git checkout -b apply-feedback
```

## 학습 목표

### 경험해야할 학습 목표
- 상속과 인터페이스를 경험
- 상속과 인터페이스를 적용해 리팩터링하는 경험

### 경험할 객체지향 생활 체조 원칙
- 규칙 4 : 한 줄에 점을 하나만 찍는다.
    - Clean Code 가이드의 디미터 법칙을 지키는 것을 의미한다.
- 규칙 6 : 모든 엔티티를 작게 유지한다.
- 규칙 7 : 3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.
- 규칙 9 : 게터 / 세터 / 프로퍼티를 쓰지 않는다

---
## Clean Code 가이드

### 객체와 자료구조
- 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다.
- 자료 구조는 자료를 그대로 공개하며 별 다른 함수는 제공하지 않는다.

### 디미터 법칙 (디메르트 법칙)
- 디미터 법칙은 모듈은 자신을 조작하는 객체의 속사정을 몰라야 한다는 법칙이다.
- 객체는 자료를 숨기고 함수를 공개한다. 즉, 객체는 조회 함수로 내부 구조를 공개하면 안 된다는 것이다.
- 다음 코드는 디미터 법칙을 어긴 것으로 보여진다.
```java
final String ouputDir = ctxt.getOptions().getScrtchDir().getAbsolutePath();
```

### 자료 전달 객체(Data Transfer Object ; DTO)
- 자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스. --> DTO
- 자바에서 DTO의 일반적인 형태는 자바 빈(Java bean) 구조 이다.

---
## 클래스

### 클래스는 작아야 한다.
- 클래스를 만들 때 첫 번째 규칙은 **크기**다. 클래스는 작아야 한다. 두 번째 규칙도 크기다. 더 작아야 한다.
- 단일 책임 원칙(Single Responsibility Principle, SRP)은 클래스나 모듈을 변경할 이유가 하나, 단 하나뿐이어야 한다는 원칙이다.
- 클래스는 책임, 즉 변경할 이유가 하나여야 한다는 의미다.
- 응집도(cohesion) - 클래스는 인스턴스 변수 수가 작아야 한다.
- 응집도를 유지하면 작은 클래스 여럿이 나온다.
- 큰 함수를 작은 함수 여럿으로 쪼개다 보면 종종 작은 클래스 여럿으로 쪼갤 기회가 생긴다. 그러면서 프로그램에 체계가 더 잡히고 구조가 더 투명해진다.

### 변경하기 쉬운 클래스
- 요구사항은 변하기 마련이다. 따라서 코드도 변하기 마련이다.
- 구현 클래스에 의존하게 되면 테스트가 어려우며, 변화에 빠르게 대응하기 힘들다. 변화에 따르게 대응하려면 DIP 원칙을 지키는 습관을 가져야 한다.
- DIP(Dependency Inversion Principle) 원칙은 클래스가 **상세한 구현이 아니라 추상화 (인터페이스)에 의존해야 한다는 원칙**이다.
- **테스트가 가능할 정도로 시스템 결합도를 낮추면 유연성과 재사용성도 더 높아진다.**
